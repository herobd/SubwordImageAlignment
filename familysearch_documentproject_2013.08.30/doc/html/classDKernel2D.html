<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DKernel2D Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>DKernel2D Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="DKernel2D" -->
<p><code>#include &lt;<a class="el" href="dkernel2d_8h_source.html">dkernel2d.h</a>&gt;</code></p>

<p><a href="classDKernel2D-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a02a010c047a7c04f792503a235ae7008">DKernel2D</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#a02a010c047a7c04f792503a235ae7008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a5c8166e332ee98a98f438ec73b44e918">DKernel2D</a> (const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Construstor (makes a deep copy of the data)  <a href="#a5c8166e332ee98a98f438ec73b44e918"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a40ffdfb72522079f15d04fbbe8028b12">~DKernel2D</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a40ffdfb72522079f15d04fbbe8028b12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#aec66f7ea8f0ccce7f15e5f686de792ec">operator=</a> (const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator (deep-copies the src kernel)  <a href="#aec66f7ea8f0ccce7f15e5f686de792ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a5699d920b64ca04d9ca768f8734206f1">operator=</a> (const <a class="el" href="classDImage.html">DImage</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment from a <a class="el" href="classDImage.html" title="This class is the internal storage structure for images of various data formats.">DImage</a> object (creates a kernel based on srcImg contents)  <a href="#a5699d920b64ca04d9ca768f8734206f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDImage.html">DImage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a854af553be3916ddd52932e55b0be553">toDImage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classDImage.html" title="This class is the internal storage structure for images of various data formats.">DImage</a> object (of type DImage_dbl_multi) with the kernel contents.  <a href="#a854af553be3916ddd52932e55b0be553"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a5be5b824b2fa2d925e92bbf518485348">isInitialized</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the kernel is initialized with data, false otherwise.  <a href="#a5be5b824b2fa2d925e92bbf518485348"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a9fe5f5dfda89d8b66832a43ce7534347">isSeparable</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the kernel is a separable kernel, false otherwise.  <a href="#a9fe5f5dfda89d8b66832a43ce7534347"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a8a55c8e44a9077d068e692a1626cf7b8">setRect</a> (int radiusX, int radiusY, bool fSeparable=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kernel to a rectangular (averaging) filter kernel.  <a href="#a8a55c8e44a9077d068e692a1626cf7b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a7e524f1180e2b801312cfc78d5b32406">setCirc</a> (int radiusX, int radiusY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kernel to a circular (actually elliptical) averaging filter kernel.  <a href="#a7e524f1180e2b801312cfc78d5b32406"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a34d782b8538f0b0e6dbe762025ea405e">setGauss</a> (int radiusX, int radiusY, bool fSeparable=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kernel to an axis-aligned Gaussian filter kernel.  <a href="#a34d782b8538f0b0e6dbe762025ea405e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a97653d1f5814311d8a702644c63f54d9">setLaplace</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kernel to a 3x3 Laplace (-8 in the center, 1 everywhere else)  <a href="#a97653d1f5814311d8a702644c63f54d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a3e27bb39e8a1ed4858e94950acc94a37">setLoG</a> (int radiusX, int radiusY, bool fSeparable=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kernel to a Laplacian of Gaussian (2nd derivative of the Gaussian)  <a href="#a3e27bb39e8a1ed4858e94950acc94a37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a2e83eb06d290ce67752a5aef051a8443">setFakeLoG</a> (int radiusX, int radiusY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kernel to a fake LaplacianOfGaussian.  <a href="#a2e83eb06d290ce67752a5aef051a8443"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a06e2732c5bd2ebe963113327f087f4b9">setData_flt</a> (float *rgData, int w, int h, bool fIsSeparable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set the kernel data to the values specified in rgData  <a href="#a06e2732c5bd2ebe963113327f087f4b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#ad6ca3474f24b48a69cfb7708c8c52ff2">setData_dbl</a> (double *rgData, int w, int h, bool fIsSeparable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set the kernel data to the values specified in rgData  <a href="#ad6ca3474f24b48a69cfb7708c8c52ff2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a7439c5655068373f95cbc3857ba0643c">scaleValues</a> (double scaleBy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the values of each position in the kernel by scaleBy.  <a href="#a7439c5655068373f95cbc3857ba0643c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a3569e77bc268e11c40e7460075d11954">setNumSigmas</a> (double sigmasX, double sigmasY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set how many sigmas to include within kernel area for gaussian-based kernels.  <a href="#a3569e77bc268e11c40e7460075d11954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a55078412f65f6d761abb163fd6a952fb">getData_flt</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to float data for this kernel  <a href="#a55078412f65f6d761abb163fd6a952fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a036fdb9ddfa72c06d4ca64875289b967">getData_dbl</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pointer to double data for this kernel  <a href="#a036fdb9ddfa72c06d4ca64875289b967"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#ae4970e8f4890960744893eda7359ede1">getRadiusX</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kernel radius along the x-axis (kernel width=radiusX*2+1)  <a href="#ae4970e8f4890960744893eda7359ede1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#afa35c6c346ea9db8ec38f1b3119ee9e5">getRadiusY</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kernel radius along the y-axis (kernel height=radiusY*2+1)  <a href="#afa35c6c346ea9db8ec38f1b3119ee9e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a3e96c79c31cf9fec488c783b1f25c0d5">getWidth</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of the kernel, which is radiusX*2+1.  <a href="#a3e96c79c31cf9fec488c783b1f25c0d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a07a2571cb135d1520f38a8517d6c2cc0">getHeight</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of the kernel, which is radiusX*2+1.  <a href="#a07a2571cb135d1520f38a8517d6c2cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDKernel2D.html#a21bddb02b318bcc4b94088fe1cfb6c13">print</a> (FILE *fout=stdout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the kernel (to 3 decimal places) to stdout (or a file)  <a href="#a21bddb02b318bcc4b94088fe1cfb6c13"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02a010c047a7c04f792503a235ae7008"></a><!-- doxytag: member="DKernel2D::DKernel2D" ref="a02a010c047a7c04f792503a235ae7008" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DKernel2D::DKernel2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Constructor. </p>

<p>References <a class="el" href="classDInstanceCounter.html#a75e8cf1ed1b759ffb22ccad0e27b9f84">DInstanceCounter::addInstance()</a>, and <a class="el" href="dkernel2d_8cpp.html#ad7c249a3a38e94d989ae9f44d623d4e8">DEFAULT_NUM_SIGMAS</a>.</p>

</div>
</div>
<a class="anchor" id="a5c8166e332ee98a98f438ec73b44e918"></a><!-- doxytag: member="DKernel2D::DKernel2D" ref="a5c8166e332ee98a98f438ec73b44e918" args="(const DKernel2D &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DKernel2D::DKernel2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy Construstor (makes a deep copy of the data) </p>

<p>References <a class="el" href="classDInstanceCounter.html#a75e8cf1ed1b759ffb22ccad0e27b9f84">DInstanceCounter::addInstance()</a>.</p>

</div>
</div>
<a class="anchor" id="a40ffdfb72522079f15d04fbbe8028b12"></a><!-- doxytag: member="DKernel2D::~DKernel2D" ref="a40ffdfb72522079f15d04fbbe8028b12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DKernel2D::~DKernel2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>References <a class="el" href="classDInstanceCounter.html#a8e69a69e579b4b12645e2be8a1fcca1e">DInstanceCounter::removeInstance()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a036fdb9ddfa72c06d4ca64875289b967"></a><!-- doxytag: member="DKernel2D::getData_dbl" ref="a036fdb9ddfa72c06d4ca64875289b967" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * DKernel2D::getData_dbl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get a pointer to double data for this kernel </p>
<p>The kernel data is stored redundantly so that either float or doubles can be used from the same kernel. For non-separable kernels, the pointer points to a buffer that is big enough for <a class="el" href="classDKernel2D.html#a3e96c79c31cf9fec488c783b1f25c0d5" title="Returns the width of the kernel, which is radiusX*2+1.">getWidth()</a>*getHeight() doubles. For separable kernels, the pointer points to a buffer that is big enough for <a class="el" href="classDKernel2D.html#a3e96c79c31cf9fec488c783b1f25c0d5" title="Returns the width of the kernel, which is radiusX*2+1.">getWidth()</a>+getHeight() doubles (add instead of multiply). </p>

</div>
</div>
<a class="anchor" id="a55078412f65f6d761abb163fd6a952fb"></a><!-- doxytag: member="DKernel2D::getData_flt" ref="a55078412f65f6d761abb163fd6a952fb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float * DKernel2D::getData_flt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get a pointer to float data for this kernel </p>
<p>The kernel data is stored redundantly so that either float or doubles can be used from the same kernel. For non-separable kernels, the pointer points to a buffer that is big enough for <a class="el" href="classDKernel2D.html#a3e96c79c31cf9fec488c783b1f25c0d5" title="Returns the width of the kernel, which is radiusX*2+1.">getWidth()</a>*getHeight() floats. For separable kernels, the pointer points to a buffer that is big enough for <a class="el" href="classDKernel2D.html#a3e96c79c31cf9fec488c783b1f25c0d5" title="Returns the width of the kernel, which is radiusX*2+1.">getWidth()</a>+getHeight() floats (add instead of multiply). </p>

</div>
</div>
<a class="anchor" id="a07a2571cb135d1520f38a8517d6c2cc0"></a><!-- doxytag: member="DKernel2D::getHeight" ref="a07a2571cb135d1520f38a8517d6c2cc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DKernel2D::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the width of the kernel, which is radiusX*2+1. </p>
<p>Note that the kernel width and height are always odd because the radius does not include the central pixel. </p>

</div>
</div>
<a class="anchor" id="ae4970e8f4890960744893eda7359ede1"></a><!-- doxytag: member="DKernel2D::getRadiusX" ref="ae4970e8f4890960744893eda7359ede1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DKernel2D::getRadiusX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the kernel radius along the x-axis (kernel width=radiusX*2+1) </p>

<p>Referenced by <a class="el" href="classDConvolver.html#abe707783ca8d9167a3cc5d87bf56b639">DConvolver::convolve_()</a>.</p>

</div>
</div>
<a class="anchor" id="afa35c6c346ea9db8ec38f1b3119ee9e5"></a><!-- doxytag: member="DKernel2D::getRadiusY" ref="afa35c6c346ea9db8ec38f1b3119ee9e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DKernel2D::getRadiusY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the kernel radius along the y-axis (kernel height=radiusY*2+1) </p>

<p>Referenced by <a class="el" href="classDConvolver.html#abe707783ca8d9167a3cc5d87bf56b639">DConvolver::convolve_()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e96c79c31cf9fec488c783b1f25c0d5"></a><!-- doxytag: member="DKernel2D::getWidth" ref="a3e96c79c31cf9fec488c783b1f25c0d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DKernel2D::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the width of the kernel, which is radiusX*2+1. </p>
<p>Note that the kernel width and height are always odd because the radius does not include the central pixel. </p>

</div>
</div>
<a class="anchor" id="a5be5b824b2fa2d925e92bbf518485348"></a><!-- doxytag: member="DKernel2D::isInitialized" ref="a5be5b824b2fa2d925e92bbf518485348" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DKernel2D::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff the kernel is initialized with data, false otherwise. </p>

<p>Referenced by <a class="el" href="classDConvolver.html#abe707783ca8d9167a3cc5d87bf56b639">DConvolver::convolve_()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fe5f5dfda89d8b66832a43ce7534347"></a><!-- doxytag: member="DKernel2D::isSeparable" ref="a9fe5f5dfda89d8b66832a43ce7534347" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DKernel2D::isSeparable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true iff the kernel is a separable kernel, false otherwise. </p>
<p>The result tells you whether the kernel IS currently a separable kernel, not whether the kernel COULD BE a separable kernel. (i.e., while a separable gaussian kernel can be created, that doesn't mean that any particular gausiian kernel has been constructed as a separable kernel. Only those that are created to be separable can be convolved separably.) </p>

<p>Referenced by <a class="el" href="classDConvolver.html#abe707783ca8d9167a3cc5d87bf56b639">DConvolver::convolve_()</a>.</p>

</div>
</div>
<a class="anchor" id="a5699d920b64ca04d9ca768f8734206f1"></a><!-- doxytag: member="DKernel2D::operator=" ref="a5699d920b64ca04d9ca768f8734206f1" args="(const DImage &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp; DKernel2D::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment from a <a class="el" href="classDImage.html" title="This class is the internal storage structure for images of various data formats.">DImage</a> object (creates a kernel based on srcImg contents) </p>

<p>References <a class="el" href="classDImage.html#aeb578208beb61b29a6742166229f1f74">DImage::convertedImgType_()</a>, <a class="el" href="classDImage.html#a593d4b7845e34d271db3d97318a4b044">DImage::dataPointer_dbl()</a>, <a class="el" href="dkernel2d_8cpp.html#ad7c249a3a38e94d989ae9f44d623d4e8">DEFAULT_NUM_SIGMAS</a>, <a class="el" href="classDImage.html#a94407a62cc8af5eb6c2d43a10def9c9aa71500ee02691368228c32ab09c74fc16">DImage::DImage_cmplx</a>, <a class="el" href="classDImage.html#a94407a62cc8af5eb6c2d43a10def9c9aac4cda31aef6500c683cc1d9ff126a1ec">DImage::DImage_dbl_multi</a>, <a class="el" href="classDImage.html#a5b4f998d5e2f38a18245e1190bfc5679">DImage::getImageType()</a>, <a class="el" href="classDImage.html#ad69a2ccf4c66e7baaa0480a14629bc04">DImage::height()</a>, <a class="el" href="classDImage.html#a364027b81140ecdcfe72f69286d23664">DImage::numChannels()</a>, and <a class="el" href="classDImage.html#af1b5a59f0561381c59389fd5ec621900">DImage::width()</a>.</p>

</div>
</div>
<a class="anchor" id="aec66f7ea8f0ccce7f15e5f686de792ec"></a><!-- doxytag: member="DKernel2D::operator=" ref="aec66f7ea8f0ccce7f15e5f686de792ec" args="(const DKernel2D &amp;src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp; DKernel2D::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDKernel2D.html">DKernel2D</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator (deep-copies the src kernel) </p>

</div>
</div>
<a class="anchor" id="a21bddb02b318bcc4b94088fe1cfb6c13"></a><!-- doxytag: member="DKernel2D::print" ref="a21bddb02b318bcc4b94088fe1cfb6c13" args="(FILE *fout=stdout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fout</em> = <code>stdout</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the contents of the kernel (to 3 decimal places) to stdout (or a file) </p>

<p>Referenced by <a class="el" href="classDEdgeDetector.html#aa4ecc0821707361b18fd7930fb440049">DEdgeDetector::prewittHorizEdges_()</a>, <a class="el" href="classDEdgeDetector.html#a34e70ab8282a2856503ed11743f07cd3">DEdgeDetector::prewittHorizEdgesKeepSign_()</a>, <a class="el" href="classDEdgeDetector.html#ae888c267d3c07f95ebb89a6daab4af06">DEdgeDetector::prewittVertEdges_()</a>, <a class="el" href="classDEdgeDetector.html#a4a4c8434c748795d5a71ea5a7d745d4f">DEdgeDetector::prewittVertEdgesKeepSign_()</a>, <a class="el" href="classDEdgeDetector.html#a0eda4c1e004925161361db627755d033">DEdgeDetector::sobel_()</a>, <a class="el" href="classDEdgeDetector.html#a52d9dff5c6dc073b4bbafb1a774215b7">DEdgeDetector::sobelHorizEdges_()</a>, <a class="el" href="classDEdgeDetector.html#aaf27b34f733a6056f8cfabc421490296">DEdgeDetector::sobelHorizEdgesKeepSign_()</a>, <a class="el" href="classDEdgeDetector.html#a848f3202198d4bb61844603a0a6e70ac">DEdgeDetector::sobelVertEdges_()</a>, and <a class="el" href="classDEdgeDetector.html#a984d773e7d1aabeebbb38d4b387d7cfb">DEdgeDetector::sobelVertEdgesKeepSign_()</a>.</p>

</div>
</div>
<a class="anchor" id="a7439c5655068373f95cbc3857ba0643c"></a><!-- doxytag: member="DKernel2D::scaleValues" ref="a7439c5655068373f95cbc3857ba0643c" args="(double scaleBy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::scaleValues </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaleBy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scales the values of each position in the kernel by scaleBy. </p>
<p>Multiplies each kernel value by scaleBy </p>

</div>
</div>
<a class="anchor" id="a7e524f1180e2b801312cfc78d5b32406"></a><!-- doxytag: member="DKernel2D::setCirc" ref="a7e524f1180e2b801312cfc78d5b32406" args="(int radiusX, int radiusY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setCirc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the kernel to a circular (actually elliptical) averaging filter kernel. </p>
<p>radiusX and radiusY specify how far the kernel extends from the central pixel. Circular kernels cannot be separable. The value of each pixel of the kernel within the elliptical area is scaled equally so that the entire filter sums to 1. Areas outside the ellipse are set to zero. </p>

</div>
</div>
<a class="anchor" id="ad6ca3474f24b48a69cfb7708c8c52ff2"></a><!-- doxytag: member="DKernel2D::setData_dbl" ref="ad6ca3474f24b48a69cfb7708c8c52ff2" args="(double *rgData, int w, int h, bool fIsSeparable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setData_dbl </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>rgData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fIsSeparable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set the kernel data to the values specified in rgData </p>
<p>The internal data arrays are allocated and the values from rgData are copied into the internal data arrays. The size of the buffers depends on whether fIsSeparable is true or false. If fIsSeparable is false, then the buffers hold w*h floats/doubles (multiply). If fIsSeparable is true, then the buffers only hold w+h floats/doubles (add). Not all kernels can be made separable, but if you use separable kernels when possible, convolution is typically much faster. When calling either setData function, the internal arrays for both float and double values are allocated and initialized to the proper values. Both functions are provided as a convenience to the caller so the data being copied can be either float or double.</p>
<p>For separable kernels, the horizontal component of the kernel is first (w values), followed by the vertical component (h values). </p>

</div>
</div>
<a class="anchor" id="a06e2732c5bd2ebe963113327f087f4b9"></a><!-- doxytag: member="DKernel2D::setData_flt" ref="a06e2732c5bd2ebe963113327f087f4b9" args="(float *rgData, int w, int h, bool fIsSeparable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setData_flt </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rgData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fIsSeparable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set the kernel data to the values specified in rgData </p>
<p>The internal data arrays are allocated and the values from rgData are copied into the internal data arrays. The size of the buffers depends on whether fIsSeparable is true or false. If fIsSeparable is false, then the buffers hold w*h floats/doubles (multiply). If fIsSeparable is true, then the buffers only hold w+h floats/doubles (add). Not all kernels can be made separable, but if you use separable kernels when possible, convolution is typically much faster. When calling either setData function, the internal arrays for both float and double values are allocated and initialized to the proper values. Both functions are provided as a convenience to the caller so the data being copied can be either float or double.</p>
<p>For separable kernels, the horizontal component of the kernel is first (w values), followed by the vertical component (h values). </p>

<p>Referenced by <a class="el" href="classDEdgeDetector.html#aa4ecc0821707361b18fd7930fb440049">DEdgeDetector::prewittHorizEdges_()</a>, <a class="el" href="classDEdgeDetector.html#a34e70ab8282a2856503ed11743f07cd3">DEdgeDetector::prewittHorizEdgesKeepSign_()</a>, <a class="el" href="classDEdgeDetector.html#ae888c267d3c07f95ebb89a6daab4af06">DEdgeDetector::prewittVertEdges_()</a>, <a class="el" href="classDEdgeDetector.html#a4a4c8434c748795d5a71ea5a7d745d4f">DEdgeDetector::prewittVertEdgesKeepSign_()</a>, <a class="el" href="classDEdgeDetector.html#a0eda4c1e004925161361db627755d033">DEdgeDetector::sobel_()</a>, <a class="el" href="classDEdgeDetector.html#a52d9dff5c6dc073b4bbafb1a774215b7">DEdgeDetector::sobelHorizEdges_()</a>, <a class="el" href="classDEdgeDetector.html#aaf27b34f733a6056f8cfabc421490296">DEdgeDetector::sobelHorizEdgesKeepSign_()</a>, <a class="el" href="classDEdgeDetector.html#a848f3202198d4bb61844603a0a6e70ac">DEdgeDetector::sobelVertEdges_()</a>, and <a class="el" href="classDEdgeDetector.html#a984d773e7d1aabeebbb38d4b387d7cfb">DEdgeDetector::sobelVertEdgesKeepSign_()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e83eb06d290ce67752a5aef051a8443"></a><!-- doxytag: member="DKernel2D::setFakeLoG" ref="a2e83eb06d290ce67752a5aef051a8443" args="(int radiusX, int radiusY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setFakeLoG </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the kernel to a fake LaplacianOfGaussian. </p>

</div>
</div>
<a class="anchor" id="a34d782b8538f0b0e6dbe762025ea405e"></a><!-- doxytag: member="DKernel2D::setGauss" ref="a34d782b8538f0b0e6dbe762025ea405e" args="(int radiusX, int radiusY, bool fSeparable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setGauss </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fSeparable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the kernel to an axis-aligned Gaussian filter kernel. </p>
<p>fSeparable should be set to true if you want a separable kernel, which is faster than a non-separable kernel when convolving. (for an NxN separable kernel, convolution is a 2*N operation instead of N*N operation for each image pixel). By default, 3 standard deviations (sigmas) fit under the gaussian curve on each side of the central pixel. If you need more (or fewer) standard deviations to fit within the kernel, use <a class="el" href="classDKernel2D.html#a3569e77bc268e11c40e7460075d11954" title="Set how many sigmas to include within kernel area for gaussian-based kernels.">setNumSigmas()</a>. </p>

<p>Referenced by <a class="el" href="classDHough.html#aacdacb330d6e03d897d9b6882f6c2cf9">DHough::houghEdgeImage_()</a>.</p>

</div>
</div>
<a class="anchor" id="a97653d1f5814311d8a702644c63f54d9"></a><!-- doxytag: member="DKernel2D::setLaplace" ref="a97653d1f5814311d8a702644c63f54d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setLaplace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the kernel to a 3x3 Laplace (-8 in the center, 1 everywhere else) </p>

<p>Referenced by <a class="el" href="classDEdgeDetector.html#aa27accdf07237a991768683ff0930e21">DEdgeDetector::laplace3x3Zeros_()</a>.</p>

</div>
</div>
<a class="anchor" id="a3e27bb39e8a1ed4858e94950acc94a37"></a><!-- doxytag: member="DKernel2D::setLoG" ref="a3e27bb39e8a1ed4858e94950acc94a37" args="(int radiusX, int radiusY, bool fSeparable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setLoG </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fSeparable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the kernel to a Laplacian of Gaussian (2nd derivative of the Gaussian) </p>

</div>
</div>
<a class="anchor" id="a3569e77bc268e11c40e7460075d11954"></a><!-- doxytag: member="DKernel2D::setNumSigmas" ref="a3569e77bc268e11c40e7460075d11954" args="(double sigmasX, double sigmasY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setNumSigmas </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmasX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigmasY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set how many sigmas to include within kernel area for gaussian-based kernels. </p>
<p>By default, when creation methods such as setGuass() and <a class="el" href="classDKernel2D.html#a3e27bb39e8a1ed4858e94950acc94a37" title="Set the kernel to a Laplacian of Gaussian (2nd derivative of the Gaussian)">setLoG()</a> are called, the kernel is created such that 3.0 standard deviations fit within the kernel created with a given radiusX and radiusY. If you want more or less standard deviations to fit within the kernel, you can adjust how many here. Note that sigmasX and sigmasY are NOT the actual sigma (standard deviation) of the gaussian function, but rather the NUMBER of sigmas that will fit, so sigmaX = (radiusX / sigmasX). </p>

</div>
</div>
<a class="anchor" id="a8a55c8e44a9077d068e692a1626cf7b8"></a><!-- doxytag: member="DKernel2D::setRect" ref="a8a55c8e44a9077d068e692a1626cf7b8" args="(int radiusX, int radiusY, bool fSeparable=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DKernel2D::setRect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radiusY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fSeparable</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the kernel to a rectangular (averaging) filter kernel. </p>
<p>radiusX and radiusY specify how far the kernel extends from the central pixel. fSeparable specifies whether this should be a separable kernel, which allows dconvolver to perform convolution faster than standard non-separable convolution. The value of each pixel of the kernel is scaled equally so that the entire filter sums to 1. </p>

<p>Referenced by <a class="el" href="classDBackgroundRemover.html#a79a7a38486997d2b0ec1a265b7f7bbf4">DBackgroundRemover::removeLowResBackground()</a>.</p>

</div>
</div>
<a class="anchor" id="a854af553be3916ddd52932e55b0be553"></a><!-- doxytag: member="DKernel2D::toDImage" ref="a854af553be3916ddd52932e55b0be553" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDImage.html">DImage</a> DKernel2D::toDImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="classDImage.html" title="This class is the internal storage structure for images of various data formats.">DImage</a> object (of type DImage_dbl_multi) with the kernel contents. </p>
<p>Non-separable kernels are formatted as one might expect. Separable kernels show the two separable functions in a "+" pattern in the image. </p>

<p>References <a class="el" href="classDImage.html#abd8a55f54bb0bd61b3fd26e8b21882de">DImage::create()</a>, <a class="el" href="classDImage.html#a593d4b7845e34d271db3d97318a4b044">DImage::dataPointer_dbl()</a>, and <a class="el" href="classDImage.html#a94407a62cc8af5eb6c2d43a10def9c9aac4cda31aef6500c683cc1d9ff126a1ec">DImage::DImage_dbl_multi</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="dkernel2d_8h_source.html">dkernel2d.h</a></li>
<li><a class="el" href="dkernel2d_8cpp.html">dkernel2d.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 30 2013 20:45:43 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
