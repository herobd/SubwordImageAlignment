<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DThresholder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>DThresholder Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="DThresholder" -->
<p>This class provides functionality for thresholding images.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="dthresholder_8h_source.html">dthresholder.h</a>&gt;</code></p>

<p><a href="classDThresholder-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#ae5efcada890ea230d523a92dc93d5611">threshImage_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, double tval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a1f3e680ec519c3b69f2d515d45bb952e">threshImageSpecial_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, double t1, double t2, double lowVal=0., double midVal=-1., double highVal=255.)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set pixel values conditional on relationship to the range [t1..t2]  <a href="#a1f3e680ec519c3b69f2d515d45bb952e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#aa431664782b2bf1ec5811788ee5b8a5c">otsuThreshImage_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs Otsu's global thresholding method  <a href="#aa431664782b2bf1ec5811788ee5b8a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a14a784269b17fbb570bfc77dba491ff5">niblackThreshImage_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, int radius=7, double K=-0.2, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs Niblack locally adaptive thresholding  <a href="#a14a784269b17fbb570bfc77dba491ff5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a18cb1f497b2c2800585b030e516537ea">sauvolaNiblackThreshImage_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, int window=15, double R=128., double K=0.5, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the modified Niblack portion (text part) of Sauvola's algorithm  <a href="#a18cb1f497b2c2800585b030e516537ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#aa061ba1f52507321f237bd929197442d">sauvolaThreshImage_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, int window=15, double R=128., double K=0.5, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs Sauvola adaptive thresholding  <a href="#aa061ba1f52507321f237bd929197442d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a74981b1ddaf40195d368d1db7e098760">milewskiThreshImage_precollaboration</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, int strokeThickness=5, int P=-1, int kappa=10, double sineConst=0.5, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs thresholding via Milewski and Govindaraju's sine wave method  <a href="#a74981b1ddaf40195d368d1db7e098760"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a0f2b501cad22b45e19a489f5b30a0cd8">milewskiThreshImage_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, int strokeThickness=5, int P=-1, int kappa=10, double sineConst=0.5, int voteThresh=4, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs thresholding via Milewski and Govindaraju's sine wave method  <a href="#a0f2b501cad22b45e19a489f5b30a0cd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a61067747c19c10f83487823685a3a731">milewskiThreshImage3_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, int strokeThickness=5, int P=-1, int kappa=10, double sineConst=0.5, int voteThresh=4, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs thresholding via Milewski and Govindaraju's sine wave method  <a href="#a61067747c19c10f83487823685a3a731"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#adabf8fd827e782ae4e06935a3b8aa72d">ccThreshImage_</a> (<a class="el" href="classDImage.html">DImage</a> &amp;imgDst, const <a class="el" href="classDImage.html">DImage</a> &amp;imgSrc, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=12, int *tval=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">performs Doug Kennard's Connected Component global thresholding method  <a href="#adabf8fd827e782ae4e06935a3b8aa72d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a8e1b135ea6906946a7964fcd237b1250">getOtsuThreshVal</a> (const <a class="el" href="classDImage.html">DImage</a> &amp;img)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">find the otsu threshold value for an image  <a href="#a8e1b135ea6906946a7964fcd237b1250"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#af26c58b11bc4ca3f6be59cb5542361d8">getOtsuThreshVal</a> (unsigned int *pHist, int histLen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">find the otsu threshold value for a histogram  <a href="#af26c58b11bc4ca3f6be59cb5542361d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a7088203be9abcea696df7f80edd45edd">getOtsuThreshVal2</a> (unsigned int *pHist, int histLen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">find the otsu threshold value for a histogram  <a href="#a7088203be9abcea696df7f80edd45edd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#af5b4e50054d339fafe8bed127638ca42">getOtsuThreshVal3</a> (unsigned int *pHist, int histLen)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">find the otsu threshold value for a histogram - not working version.  <a href="#af5b4e50054d339fafe8bed127638ca42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a0aa6e66ffe4c0c00cf05e6a0a2e1497f">getOtsuThreshVal</a> (unsigned char *pImgData, int w, int h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a75921e76399b45ffac363d650b812c45">getCCThreshVal</a> (const <a class="el" href="classDImage.html">DImage</a> &amp;img, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">find the global threshold that results in the fewest Connected Components  <a href="#a75921e76399b45ffac363d650b812c45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDThresholder.html#a768afa392d2a6435b1c8f87a68762228">getCCThreshVal2</a> (const <a class="el" href="classDImage.html">DImage</a> &amp;img, <a class="el" href="classDProgress.html">DProgress</a> *<a class="el" href="dminfilter_8cpp.html#a23b67971d28c93bee3d0e71389844aa1">pProg</a>=NULL, int <a class="el" href="dthresholder_8cpp.html#aa84c6f4ba6f33ec1a17b3723fc593290">numThreads</a>=1)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class provides functionality for thresholding images. </p>
<p>Unless stated otherwise, image pixels EQUAL to a threshold value are set to zero when performing global thresholding, just like the pixels less than the threshold value. Only pixels greater than the threshold are set to 255. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adabf8fd827e782ae4e06935a3b8aa72d"></a><!-- doxytag: member="DThresholder::ccThreshImage_" ref="adabf8fd827e782ae4e06935a3b8aa72d" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, DProgress *pProg=NULL, int numThreads=12, int *tval=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::ccThreshImage_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>tval</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs Doug Kennard's Connected Component global thresholding method </p>
<p>This function just calls <a class="el" href="classDThresholder.html#a75921e76399b45ffac363d650b812c45" title="find the global threshold that results in the fewest Connected Components">getCCThreshVal()</a> to get the Connected Component threshold value, and then calls <a class="el" href="classDThresholder.html#ae5efcada890ea230d523a92dc93d5611">threshImage_()</a> with that thrshold value. Since this is a global threshold method, it may be best to perform background removal on the image before choosing and applying a threshold. If tval is not NULL, then it will be filled with the threshold value used for the threshold. </p>

</div>
</div>
<a class="anchor" id="a75921e76399b45ffac363d650b812c45"></a><!-- doxytag: member="DThresholder::getCCThreshVal" ref="a75921e76399b45ffac363d650b812c45" args="(const DImage &amp;img, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DThresholder::getCCThreshVal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find the global threshold that results in the fewest Connected Components </p>
<p>This method chooses the threshold value that results in the least number of connected components (CCs). This is based on the assumption that fewer CCs will be found when words/characters are well-connected instead of disjoint (disjoint characters resulting from a threshold that is too low), and when the threshold is not so high that extra noise is introduced. In the limit, however, everything gets connected into one big component, so heuristics are used to short-circuit turning the whole page (or a large portion of it) into one big blob. Possible threshold values returned range from the otsu value (the algorithm's starting point) to 254. </p>

</div>
</div>
<a class="anchor" id="a768afa392d2a6435b1c8f87a68762228"></a><!-- doxytag: member="DThresholder::getCCThreshVal2" ref="a768afa392d2a6435b1c8f87a68762228" args="(const DImage &amp;img, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double DThresholder::getCCThreshVal2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e1b135ea6906946a7964fcd237b1250"></a><!-- doxytag: member="DThresholder::getOtsuThreshVal" ref="a8e1b135ea6906946a7964fcd237b1250" args="(const DImage &amp;img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DThresholder::getOtsuThreshVal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find the otsu threshold value for an image </p>

<p>Referenced by <a class="el" href="classDGlobalSkew.html#a9ee7eb827995a99e448117b62cd11529">DGlobalSkew::getSkewAng_fast()</a>.</p>

</div>
</div>
<a class="anchor" id="af26c58b11bc4ca3f6be59cb5542361d8"></a><!-- doxytag: member="DThresholder::getOtsuThreshVal" ref="af26c58b11bc4ca3f6be59cb5542361d8" args="(unsigned int *pHist, int histLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DThresholder::getOtsuThreshVal </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>histLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find the otsu threshold value for a histogram </p>
<p>This version is optimized better than the other version because it just uses means, not variances, and the means are updated iteratively instead of re-calculated for each possible threshold. Pixel counts are used instead of probabilities since the number of pixels is constant and we are just maximizing the function, and only the between-class variance is calculated (not the total variance) since the total variance is constant also. If there are not at least two levels in the histogram, then the result doesn't matter, but histLen-1 is returned just in case the caller wants to know (histLen-1 will never be the value otherwise since thresholds include all values &lt;= T). </p>

</div>
</div>
<a class="anchor" id="a0aa6e66ffe4c0c00cf05e6a0a2e1497f"></a><!-- doxytag: member="DThresholder::getOtsuThreshVal" ref="a0aa6e66ffe4c0c00cf05e6a0a2e1497f" args="(unsigned char *pImgData, int w, int h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double DThresholder::getOtsuThreshVal </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pImgData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7088203be9abcea696df7f80edd45edd"></a><!-- doxytag: member="DThresholder::getOtsuThreshVal2" ref="a7088203be9abcea696df7f80edd45edd" args="(unsigned int *pHist, int histLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DThresholder::getOtsuThreshVal2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>histLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find the otsu threshold value for a histogram </p>

</div>
</div>
<a class="anchor" id="af5b4e50054d339fafe8bed127638ca42"></a><!-- doxytag: member="DThresholder::getOtsuThreshVal3" ref="af5b4e50054d339fafe8bed127638ca42" args="(unsigned int *pHist, int histLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DThresholder::getOtsuThreshVal3 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>histLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find the otsu threshold value for a histogram - not working version. </p>

</div>
</div>
<a class="anchor" id="a61067747c19c10f83487823685a3a731"></a><!-- doxytag: member="DThresholder::milewskiThreshImage3_" ref="a61067747c19c10f83487823685a3a731" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, int strokeThickness=5, int P=&#45;1, int kappa=10, double sineConst=0.5, int voteThresh=4, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::milewskiThreshImage3_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strokeThickness</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kappa</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sineConst</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voteThresh</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs thresholding via Milewski and Govindaraju's sine wave method </p>
<p>Most algorithm parameters are based on an estimate of pen stroke thickness. In their research, they used 5 pixels as stroke width, which resulted in phi=5, N=5, P=3. Technically, parameter P could fall within a range of values that is limited by the stroke thickness, but if P is unspecified (-1), then we will use the upper bound of the range. The sineConst parameter was empirically chosen by the authors as 0.5. It determines the frequency of the sine wave. (The equation they use is y=2*strokeThickness*sin(0.5*x).) It makes sense that we would want to adjust that if the writing is much bigger, so I (not the paper authors) suggest maybe making it a function of the stroke thickness, (i.e. sineConst = 5./(2.*strokeThickness)). The parameter voteThresh is how many (minimum) of the directions must have a minimum mask lighter than the central mask in order for the center pixel to be marked as foreground (black).</p>
<p>This thresholding algorithm was developed for use with Carbon copy documents from medical paperwork, but it seems that noisy microfilm has many of the same characteristics, and may benefit from its use. The paper I read to implement this is currently in press in Pattern Recognition, and pre-press manuscript is available online at ScienceDirect.com. I have added an additional stopping criteria for implementation purposes: no sine wave will continue past three cycles, even if the 2nd condition hasn't been met yet. Also, in this implementation I do not necessarily calculate all 8 sine wave minimums, I only trace a given wave until a mean smaller than the central mask mean is found (which guarantees that the minimum for that wave will also be smaller), and once voteThresh waves are guaranteed to be smaller, I don't bother computing the rest since the result will still be a foreground pixel no matter what the minimum of the rest of the waves are.</p>
<p>Citation: Robert Milewski and Venu Govindaraju, Binarization and cleanup of handwritten text from carbon copy medical form images, Pattern Recognition (2007), doi:10.1016/j.patcog.2007.08.018.</p>
<p>Also, many thanks to Rob Milewski for his willingness to provide me with a sample result from his binarizer for me to compare the results of my implementation to, and who also answered several of my questions about the algorithm when I was trying to track down mistakes in my initial implementation. </p>

</div>
</div>
<a class="anchor" id="a0f2b501cad22b45e19a489f5b30a0cd8"></a><!-- doxytag: member="DThresholder::milewskiThreshImage_" ref="a0f2b501cad22b45e19a489f5b30a0cd8" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, int strokeThickness=5, int P=&#45;1, int kappa=10, double sineConst=0.5, int voteThresh=4, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::milewskiThreshImage_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strokeThickness</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kappa</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sineConst</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voteThresh</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs thresholding via Milewski and Govindaraju's sine wave method </p>
<p>Most algorithm parameters are based on an estimate of pen stroke thickness. In their research, they used 5 pixels as stroke width, which resulted in phi=5, N=5, P=3. Technically, parameter P could fall within a range of values that is limited by the stroke thickness, but if P is unspecified (-1), then we will use the upper bound of the range. The sineConst parameter was empirically chosen by the authors as 0.5. It determines the frequency of the sine wave. (The equation they use is y=2*strokeThickness*sin(0.5*x).) It makes sense that we would want to adjust that if the writing is much bigger, so I (not the paper authors) suggest maybe making it a function of the stroke thickness, (i.e. sineConst = 5./(2.*strokeThickness)). The parameter voteThresh is how many (minimum) of the directions must have a minimum mask lighter than the central mask in order for the center pixel to be marked as foreground (black).</p>
<p>This thresholding algorithm was developed for use with Carbon copy documents from medical paperwork, but it seems that noisy microfilm has many of the same characteristics, and may benefit from its use. The paper I read to implement this is currently in press in Pattern Recognition, and pre-press manuscript is available online at ScienceDirect.com. I have added an additional stopping criteria for implementation purposes: no sine wave will continue past three cycles, even if the 2nd condition hasn't been met yet. Also, in this implementation I do not necessarily calculate all 8 sine wave minimums, I only trace a given wave until a mean smaller than the central mask mean is found (which guarantees that the minimum for that wave will also be smaller), and once voteThresh waves are guaranteed to be smaller, I don't bother computing the rest since the result will still be a foreground pixel no matter what the minimum of the rest of the waves are.</p>
<p>Citation: Robert Milewski and Venu Govindaraju, Binarization and cleanup of handwritten text from carbon copy medical form images, Pattern Recognition (2007), doi:10.1016/j.patcog.2007.08.018.</p>
<p>Also, many thanks to Rob Milewski for his willingness to provide me with a sample result from his binarizer for me to compare the results of my implementation to, and who also answered several of my questions about the algorithm when I was trying to track down mistakes in my initial implementation. </p>

</div>
</div>
<a class="anchor" id="a74981b1ddaf40195d368d1db7e098760"></a><!-- doxytag: member="DThresholder::milewskiThreshImage_precollaboration" ref="a74981b1ddaf40195d368d1db7e098760" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, int strokeThickness=5, int P=&#45;1, int kappa=10, double sineConst=0.5, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::milewskiThreshImage_precollaboration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strokeThickness</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>P</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kappa</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sineConst</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs thresholding via Milewski and Govindaraju's sine wave method </p>
<p>Most algorithm parameters are based on an estimate of pen stroke thickness. In their research, they used 5 pixels as stroke width, which resulted in phi=5, N=5, P=3. Technically, parameter P could fall within a range of values that is limited by the stroke thickness, but if P is unspecified (-1), then we will use the upper bound of the range. The sineConst parameter was empirically chosen by the authors as 0.5. It determines the frequency of the sine wave. (The equation they use is y=2*strokeThickness*sin(0.5*x).) It makes sense that we would want to adjust that if the writing is much bigger, so I (not the paper authors) suggest maybe making it a function of the stroke thickness, (i.e. sineConst = 5./(2.*strokeThickness)).</p>
<p>This thresholding algorithm was developed for use with Carbon copy documents from medical paperwork, but it seems that noisy microfilm has many of the same characteristics, and may benefit from its use. The paper I read to implement this is currently in press in Pattern Recognition, and pre-press manuscript is available online at ScienceDirect.com. I have added an additional stopping criteria for implementation purposes: no sine wave will continue past three cycles, even if the 2nd condition hasn't been met yet. Also, in this implementation I do not necessarily calculate all 8 sine wave minimums, I only trace a given wave until a mean smaller than the central mask mean is found (which guarantees that the minimum for that wave will also be smaller), and once 4 waves are guaranteed to be smaller, I don't bother computing the rest since the result will still be a foreground pixel no matter what the minimum of the rest of the waves are.</p>
<p>Citation: Robert Milewski and Venu Govindaraju, Binarization and cleanup of handwritten text from carbon copy medical form images, Pattern Recognition (2007), doi:10.1016/j.patcog.2007.08.018. </p>

</div>
</div>
<a class="anchor" id="a14a784269b17fbb570bfc77dba491ff5"></a><!-- doxytag: member="DThresholder::niblackThreshImage_" ref="a14a784269b17fbb570bfc77dba491ff5" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, int radius=7, double K=&#45;0.2, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::niblackThreshImage_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>K</em> = <code>-0.2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs Niblack locally adaptive thresholding </p>
<p>The window size is (2*radius+1). K is the constant.</p>
<p>This implementation uses integral images for speed, as described in "Efficient Implementation of Local Adaptive Thresholding
    Techniques Using Integral Images" by Shafait, Keysers, and Breuel to appear in Document Recognition and Retrieval (DRR) 2008. </p>

</div>
</div>
<a class="anchor" id="aa431664782b2bf1ec5811788ee5b8a5c"></a><!-- doxytag: member="DThresholder::otsuThreshImage_" ref="aa431664782b2bf1ec5811788ee5b8a5c" args="(DImage &amp;imgDst, const DImage &amp;imgSrc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::otsuThreshImage_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs Otsu's global thresholding method </p>
<p>This function just calls <a class="el" href="classDThresholder.html#a8e1b135ea6906946a7964fcd237b1250" title="find the otsu threshold value for an image">getOtsuThreshVal()</a> to get the Otsu threshold value, and then calls <a class="el" href="classDThresholder.html#ae5efcada890ea230d523a92dc93d5611">threshImage_()</a> with that Otsu value. Otsu's method assumes a bimodal distribution (2 classes) and tries all threshold values, picking the one that minimizes within-class variance as the Otsu threshold. Since this is a global threshold method, it may be best to perform background removal on the image before choosing and applying a threshold. </p>

</div>
</div>
<a class="anchor" id="a18cb1f497b2c2800585b030e516537ea"></a><!-- doxytag: member="DThresholder::sauvolaNiblackThreshImage_" ref="a18cb1f497b2c2800585b030e516537ea" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, int window=15, double R=128., double K=0.5, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::sauvolaNiblackThreshImage_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em> = <code>128.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>K</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs the modified Niblack portion (text part) of Sauvola's algorithm </p>
<p>The window size "window" should vary linearly from 10 to 20 pixels as image dpi varies from 75 to 300. R is the dynamic range of standard deviation, and K gets positive values (0.5 is what Sauvola used). This function does NOT implement the entire Sauvola method. It assumes the entire image is text and performs Sauvola's modified Niblack thresholding. However, most comparisons I have seen in the literature ONLY implement this part. I do not recall seeing any implementations of Sauvola's entire algorithm used for comparisons by anyone but Sauvols himself.</p>
<p>This implementation uses integral images for speed, as described in "Efficient Implementation of Local Adaptive Thresholding
    Techniques Using Integral Images" by Shafait, Keysers, and Breuel that was to appear in Proc. Document Recognition and Retrieval XV, IST/SPIE Annual Symposium, San Jose, CA, January 2008. TODO: double-check this to make sure I am not off by one (in the meanfilter, I had to pad the left and top by radius+1 but right and bottom just by radius </p>

</div>
</div>
<a class="anchor" id="aa061ba1f52507321f237bd929197442d"></a><!-- doxytag: member="DThresholder::sauvolaThreshImage_" ref="aa061ba1f52507321f237bd929197442d" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, int window=15, double R=128., double K=0.5, DProgress *pProg=NULL, int numThreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::sauvolaThreshImage_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em> = <code>128.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>K</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDProgress.html">DProgress</a> *&#160;</td>
          <td class="paramname"><em>pProg</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numThreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>performs Sauvola adaptive thresholding </p>
<p>The window size "window" should vary linearly from 10 to 20 pixels as image dpi varies from 75 to 300. R is the dynamic range of standard deviation, and K gets positive values (0.5 is what Sauvola used). To speed up the algorithm, the paper suggests that a threshold for every nth pixel can be computed instead of every pixel and interpolation is used to pick threshold values for the pixels in between. We assume n=1 (threshold is computed for every pixel). </p>

</div>
</div>
<a class="anchor" id="ae5efcada890ea230d523a92dc93d5611"></a><!-- doxytag: member="DThresholder::threshImage_" ref="ae5efcada890ea230d523a92dc93d5611" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, double tval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::threshImage_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>perform a simple threshold at tval pixels less than or equal to tval go to zero, pixels greater than tval go to 255. Source and destination images may both be the same image since this is a simple threshold. </p>

<p>Referenced by <a class="el" href="classDMedialAxis.html#a53a96d6579e27ed4445ef9a46e52204c">DMedialAxis::getMedialAxisImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f3e680ec519c3b69f2d515d45bb952e"></a><!-- doxytag: member="DThresholder::threshImageSpecial_" ref="a1f3e680ec519c3b69f2d515d45bb952e" args="(DImage &amp;imgDst, const DImage &amp;imgSrc, double t1, double t2, double lowVal=0., double midVal=&#45;1., double highVal=255.)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DThresholder::threshImageSpecial_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDImage.html">DImage</a> &amp;&#160;</td>
          <td class="paramname"><em>imgSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lowVal</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>midVal</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>highVal</em> = <code>255.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set pixel values conditional on relationship to the range [t1..t2] </p>
<p>For each pixel "p": If p&lt;t1, p gets set to lowVal (or left alone if lowVal==-1). If t1&lt;=p&lt;=t2, then p gets set to midVal (or left alone if midVal==-1). If t2&lt;p, then p gets set to highVal (or left alone if highVal==-1). Source and destination images may both be the same image. To use only one threshold, set t1==t2. </p>

<p>Referenced by <a class="el" href="classDGlobalSkew.html#a9ee7eb827995a99e448117b62cd11529">DGlobalSkew::getSkewAng_fast()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="dthresholder_8h_source.html">dthresholder.h</a></li>
<li><a class="el" href="dthresholder_8cpp.html">dthresholder.cpp</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Aug 30 2013 20:45:43 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
